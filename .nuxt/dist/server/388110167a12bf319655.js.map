{"version":3,"file":"388110167a12bf319655.js","sources":["webpack:///./node_modules/aos/dist/aos.css","webpack:///./components/blocks/Main.vue?96d5","webpack:///./plugins/H2.js","webpack:///./plugins/Title.js","webpack:///./components/blocks/Main.vue","webpack:///./plugins/H3.js","webpack:///./components/elements/Project.vue"],"sourcesContent":["// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../css-loader/dist/cjs.js??ref--5-oneOf-1-1!../../postcss-loader/src/index.js??ref--5-oneOf-1-2!./aos.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\nrequire(\"!../../vue-style-loader/lib/addStylesServer.js\").default(\"3d39bbb8\", content, true)","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"main\"},[_vm._ssrNode(\"<canvas id=\\\"scene\\\"></canvas>\"),_vm._ssrNode(\"<div class=\\\"title\\\">\",\"</div>\",[_c('H1',{attrs:{\"typed\":\"normal\",\"data-aos\":\"zoom-in\",\"data-aos-duration\":\"1000\"}},[_vm._v(\"Andrey Wayne\")]),_c('H2',{attrs:{\"typed\":\"main\",\"data-aos\":\"fade-up\",\"data-aos-duration\":\"1500\"}},[_vm._v(\"Креативный frontend разработчик\")])],1),_vm._ssrNode(\"<div class=\\\"scroll\\\">\",\"</div>\",[_vm._ssrNode(\"<img src=\\\"/img/arrow-scroll.svg\\\">\"),_vm._ssrNode(\"<div class=\\\"scroll-title\\\">\",\"</div>\",[_c('Title',{attrs:{\"typed\":\"min\"}},[_vm._v(\"s\"),_c('br'),_vm._v(\"c\"),_c('br'),_vm._v(\"r\"),_c('br'),_vm._v(\"o\"),_c('br'),_vm._v(\"l\"),_c('br'),_vm._v(\"l\")])],1)],2)],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import styled, { css } from 'vue-styled-components'\n\nconst config = {\n  typed: String,\n  styled: ''\n}\n\nexport default styled('h2', config)`\n  ${props => {\n    switch (props.typed) {\n      case 'main':\n        return css`\n          font-family: Medium;\n          font-size: 24px;\n          color: #FFFFFF;\n          letter-spacing: 0.5px;\n          @media screen and (max-width: 1279px) {\n            font-size: 18px;\n          }\n        `\n      case 'big':\n        return css`\n          font-family: Medium;\n          font-size: 125px;\n          color: white;\n          line-height: 140px;\n          letter-spacing: 0.5px;\n          @media screen and (max-width: 1279px) {\n            font-size: 24px;\n            line-height: 28px;\n          }\n        `\n      case 'footer':\n        return css`\n          font-family: Medium;\n          font-size: 70px;\n          line-height: 72px;\n          color: white;\n          @media screen and (max-width: 1279px) {\n            font-size: 24px;\n            line-height: 28px;\n          }\n        `\n    }\n  }}\n`\n","import styled, { css } from 'vue-styled-components'\n\nconst config = {\n  typed: String,\n  styled: ''\n}\n\nexport default styled('p', config)`\n  ${props => {\n    switch (props.typed) {\n      case 'normal':\n        return css`\n          font-family: Light;\n          font-size: 18px;\n          color: #FFFFFF;\n          letter-spacing: 0.5px;\n          line-height: 35px;\n        `\n      case 'min':\n        return css`\n          font-family: Light;\n          font-size: 14px;\n          color: #FFFFFF;\n        `\n    }\n  }}\n`\n","//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport AppLogo from '~/components/AppLogo.vue'\nimport TweenMax from 'gsap'\nconst THREE = require('three');\nimport H1 from '~/plugins/H1'\nimport H2 from '~/plugins/H2'\nimport AOS from 'aos'\nimport 'aos/dist/aos.css'\nimport Parallax from 'vue-parallaxy'\nimport Title from '~/plugins/Title'\nexport default {\n  components: {\n    H1,\n    H2,\n    Parallax,\n    Title\n  },\n  mounted() {\n      var module = global.noise = {};\n\n      function Grad(x, y, z) {\n        this.x = x; this.y = y; this.z = z;\n      }\n\n      Grad.prototype.dot2 = function(x, y) {\n        return this.x*x + this.y*y;\n      };\n\n      Grad.prototype.dot3 = function(x, y, z) {\n        return this.x*x + this.y*y + this.z*z;\n      };\n\n      var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\n                   new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\n                   new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\n\n      var p = [151,160,137,91,90,15,\n      131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n      190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n      88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n      77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n      102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n      135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n      5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n      223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n      129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n      251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n      49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n      138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\n      // To remove the need for index wrapping, double the permutation table length\n      var perm = new Array(512);\n      var gradP = new Array(512);\n\n      // This isn't a very good seeding function, but it works ok. It supports 2^16\n      // different seed values. Write something better if you need more seeds.\n      module.seed = function(seed) {\n        if(seed > 0 && seed < 1) {\n          // Scale the seed out\n          seed *= 65536;\n        }\n\n        seed = Math.floor(seed);\n        if(seed < 256) {\n          seed |= seed << 8;\n        }\n\n        for(var i = 0; i < 256; i++) {\n          var v;\n          if (i & 1) {\n            v = p[i] ^ (seed & 255);\n          } else {\n            v = p[i] ^ ((seed>>8) & 255);\n          }\n\n          perm[i] = perm[i + 256] = v;\n          gradP[i] = gradP[i + 256] = grad3[v % 12];\n        }\n      };\n\n      module.seed(0);\n\n      /*\n      for(var i=0; i<256; i++) {\n        perm[i] = perm[i + 256] = p[i];\n        gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\n      }*/\n\n      // Skewing and unskewing factors for 2, 3, and 4 dimensions\n      var F2 = 0.5*(Math.sqrt(3)-1);\n      var G2 = (3-Math.sqrt(3))/6;\n\n      var F3 = 1/3;\n      var G3 = 1/6;\n\n      // 2D simplex noise\n      module.simplex2 = function(xin, yin) {\n        var n0, n1, n2; // Noise contributions from the three corners\n        // Skew the input space to determine which simplex cell we're in\n        var s = (xin+yin)*F2; // Hairy factor for 2D\n        var i = Math.floor(xin+s);\n        var j = Math.floor(yin+s);\n        var t = (i+j)*G2;\n        var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\n        var y0 = yin-j+t;\n        // For the 2D case, the simplex shape is an equilateral triangle.\n        // Determine which simplex we are in.\n        var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n        if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n          i1=1; j1=0;\n        } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n          i1=0; j1=1;\n        }\n        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n        // c = (3-sqrt(3))/6\n        var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n        var y1 = y0 - j1 + G2;\n        var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n        var y2 = y0 - 1 + 2 * G2;\n        // Work out the hashed gradient indices of the three simplex corners\n        i &= 255;\n        j &= 255;\n        var gi0 = gradP[i+perm[j]];\n        var gi1 = gradP[i+i1+perm[j+j1]];\n        var gi2 = gradP[i+1+perm[j+1]];\n        // Calculate the contribution from the three corners\n        var t0 = 0.5 - x0*x0-y0*y0;\n        if(t0<0) {\n          n0 = 0;\n        } else {\n          t0 *= t0;\n          n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n        }\n        var t1 = 0.5 - x1*x1-y1*y1;\n        if(t1<0) {\n          n1 = 0;\n        } else {\n          t1 *= t1;\n          n1 = t1 * t1 * gi1.dot2(x1, y1);\n        }\n        var t2 = 0.5 - x2*x2-y2*y2;\n        if(t2<0) {\n          n2 = 0;\n        } else {\n          t2 *= t2;\n          n2 = t2 * t2 * gi2.dot2(x2, y2);\n        }\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to return values in the interval [-1,1].\n        return 70 * (n0 + n1 + n2);\n      };\n\n      // 3D simplex noise\n      module.simplex3 = function(xin, yin, zin) {\n        var n0, n1, n2, n3; // Noise contributions from the four corners\n\n        // Skew the input space to determine which simplex cell we're in\n        var s = (xin+yin+zin)*F3; // Hairy factor for 2D\n        var i = Math.floor(xin+s);\n        var j = Math.floor(yin+s);\n        var k = Math.floor(zin+s);\n\n        var t = (i+j+k)*G3;\n        var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\n        var y0 = yin-j+t;\n        var z0 = zin-k+t;\n\n        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n        // Determine which simplex we are in.\n        var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n        var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n        if(x0 >= y0) {\n          if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }\n          else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }\n          else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }\n        } else {\n          if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }\n          else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }\n          else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }\n        }\n        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n        // c = 1/6.\n        var x1 = x0 - i1 + G3; // Offsets for second corner\n        var y1 = y0 - j1 + G3;\n        var z1 = z0 - k1 + G3;\n\n        var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n        var y2 = y0 - j2 + 2 * G3;\n        var z2 = z0 - k2 + 2 * G3;\n\n        var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n        var y3 = y0 - 1 + 3 * G3;\n        var z3 = z0 - 1 + 3 * G3;\n\n        // Work out the hashed gradient indices of the four simplex corners\n        i &= 255;\n        j &= 255;\n        k &= 255;\n        var gi0 = gradP[i+   perm[j+   perm[k   ]]];\n        var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];\n        var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];\n        var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];\n\n        // Calculate the contribution from the four corners\n        var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n        if(t0<0) {\n          n0 = 0;\n        } else {\n          t0 *= t0;\n          n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\n        }\n        var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n        if(t1<0) {\n          n1 = 0;\n        } else {\n          t1 *= t1;\n          n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n        }\n        var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n        if(t2<0) {\n          n2 = 0;\n        } else {\n          t2 *= t2;\n          n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n        }\n        var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n        if(t3<0) {\n          n3 = 0;\n        } else {\n          t3 *= t3;\n          n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n        }\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to return values in the interval [-1,1].\n        return 32 * (n0 + n1 + n2 + n3);\n\n      };\n\n      // ##### Perlin noise stuff\n\n      function fade(t) {\n        return t*t*t*(t*(t*6-15)+10);\n      }\n\n      function lerp(a, b, t) {\n        return (1-t)*a + t*b;\n      }\n\n      // 2D Perlin Noise\n      module.perlin2 = function(x, y) {\n        // Find unit grid cell containing point\n        var X = Math.floor(x), Y = Math.floor(y);\n        // Get relative xy coordinates of point within that cell\n        x = x - X; y = y - Y;\n        // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n        X = X & 255; Y = Y & 255;\n\n        // Calculate noise contributions from each of the four corners\n        var n00 = gradP[X+perm[Y]].dot2(x, y);\n        var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);\n        var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);\n        var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);\n\n        // Compute the fade curve value for x\n        var u = fade(x);\n\n        // Interpolate the four results\n        return lerp(\n            lerp(n00, n10, u),\n            lerp(n01, n11, u),\n           fade(y));\n      };\n\n      // 3D Perlin Noise\n      module.perlin3 = function(x, y, z) {\n        // Find unit grid cell containing point\n        var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\n        // Get relative xyz coordinates of point within that cell\n        x = x - X; y = y - Y; z = z - Z;\n        // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n        X = X & 255; Y = Y & 255; Z = Z & 255;\n\n        // Calculate noise contributions from each of the eight corners\n        var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);\n        var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);\n        var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);\n        var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);\n        var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);\n        var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);\n        var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);\n        var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);\n\n        // Compute the fade curve value for x, y, z\n        var u = fade(x);\n        var v = fade(y);\n        var w = fade(z);\n\n        // Interpolate\n        return lerp(\n            lerp(\n              lerp(n000, n100, u),\n              lerp(n001, n101, u), w),\n            lerp(\n              lerp(n010, n110, u),\n              lerp(n011, n111, u), w),\n           v);\n      };\n\n    {\n    \tsetTimeout(() => document.body.classList.add('render'), 60);\n    \tconst navdemos = Array.from(document.querySelectorAll('nav.demos > .demo'));\n    \tconst total = navdemos.length;\n    \tconst current = navdemos.findIndex(el => el.classList.contains('demo--current'));\n    \tconst navigate = (linkEl) => {\n    \t\tdocument.body.classList.remove('render');\n    \t\tdocument.body.addEventListener('transitionend', () => window.location = linkEl.href);\n    \t};\n    \tnavdemos.forEach(link => link.addEventListener('click', (ev) => {\n    \t\tev.preventDefault();\n    \t\tnavigate(ev.target);\n    \t}));\n    \tdocument.addEventListener('keydown', (ev) => {\n    \t\tconst keyCode = ev.keyCode || ev.which;\n    \t\tlet linkEl;\n    \t\tif ( keyCode === 37 ) {\n    \t\t\tlinkEl = current > 0 ? navdemos[current-1] : navdemos[total-1];\n    \t\t}\n    \t\telse if ( keyCode === 39 ) {\n    \t\t\tlinkEl = current < total-1 ? navdemos[current+1] : navdemos[0];\n    \t\t}\n    \t\telse {\n    \t\t\treturn false;\n    \t\t}\n    \t\tnavigate(linkEl);\n    \t});\n    }\n\n    var canvas = document.querySelector('canvas');\n    var width = canvas.offsetWidth,\n        height = canvas.offsetHeight;\n\n    var renderer = new THREE.WebGLRenderer({\n        canvas: canvas,\n        antialias: true,\n        alpha: true\n    });\n    renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);\n    renderer.setSize(width, height);\n    renderer.setClearColor(0x000000,0);\n\n    var scene = new THREE.Scene();\n\n    var camera = new THREE.PerspectiveCamera(40, width / height, 0.1, 1000);\n    camera.position.set(0, 0, 350);\n\n    var sphere = new THREE.Group();\n    scene.add(sphere);\n    var material = new THREE.LineBasicMaterial({\n        color: 0xfe0e55\n    });\n    var linesAmount = 18;\n    var radius = 100;\n    var verticesAmount = 50;\n    for(var j=0;j<linesAmount;j++){\n        var index = j;\n        var geometry = new THREE.Geometry();\n        geometry.y = (index/linesAmount) * radius*2;\n        for(var i=0;i<=verticesAmount;i++) {\n            var vector = new THREE.Vector3();\n            vector.x = Math.cos(i/verticesAmount * Math.PI*2);\n            vector.z = Math.sin(i/verticesAmount * Math.PI*2);\n            vector._o = vector.clone();\n            geometry.vertices.push(vector);\n        }\n        var line = new THREE.Line(geometry, material);\n        sphere.add(line);\n    }\n\n    function updateVertices (a) {\n     for(var j=0;j<sphere.children.length;j++){\n         var line = sphere.children[j];\n         line.geometry.y += 0.3;\n         if(line.geometry.y > radius*2) {\n             line.geometry.y = 0;\n         }\n         var radiusHeight = Math.sqrt(line.geometry.y * (2*radius-line.geometry.y));\n         for(var i=0;i<=verticesAmount;i++) {\n             var vector = line.geometry.vertices[i];\n                var ratio = noise.simplex3(vector.x*0.009, vector.z*0.009 + a*0.0006, line.geometry.y*0.009) * 15;\n                vector.copy(vector._o);\n                vector.multiplyScalar(radiusHeight + ratio);\n                vector.y = line.geometry.y - radius;\n            }\n         line.geometry.verticesNeedUpdate = true;\n     }\n    }\n\n    function render(a) {\n        requestAnimationFrame(render);\n        updateVertices(a);\n        renderer.render(scene, camera);\n    }\n\n    function onResize() {\n        canvas.style.width = '';\n        canvas.style.height = '';\n        width = canvas.offsetWidth;\n        height = canvas.offsetHeight;\n        camera.aspect = width / height;\n        camera.updateProjectionMatrix();\n        renderer.setSize(width, height);\n    }\n\n    var mouse = new THREE.Vector2(0.8, 0.5);\n    function onMouseMove(e) {\n        mouse.y = e.clientY / window.innerHeight;\n        TweenMax.to(sphere.rotation, 2, {\n            x : (mouse.y * 1),\n            ease:Power1.easeOut\n        });\n    }\n\n    requestAnimationFrame(render);\n    window.addEventListener(\"mousemove\", onMouseMove);\n    var resizeTm;\n    window.addEventListener(\"resize\", function(){\n        resizeTm = clearTimeout(resizeTm);\n        resizeTm = setTimeout(onResize, 200);\n    });\n  },\n}\n","import styled, { css } from 'vue-styled-components'\n\nconst config = {\n  typed: String,\n  styled: ''\n}\n\nexport default styled('h3', config)`\n  ${props => {\n    switch (props.typed) {\n      case 'project':\n        return css`\n          font-family: Medium;\n          font-size: 24px;\n          color: #FFFFFF;\n          letter-spacing: 0.5px;\n          @media screen and (max-width: 1279px) {\n            font-size: 18px;\n          }\n        `\n    }\n  }}\n`\n","import mod from \"-!../../node_modules/babel-loader/lib/index.js??ref--2-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Project.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/babel-loader/lib/index.js??ref--2-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Project.vue?vue&type=script&lang=js&\""],"mappings":"AAGA;;;;;;;ACHA;;;;;;;;;;ACEA;AAMA;;;;;;;;AAYA;;;;;;;;;;AAYA;;;;;;;;;;AC9BA;AAMA;;;;;;AAUA;;;;;ACUA;ACpBA;;;;;;;;;ACRA","sourceRoot":""}